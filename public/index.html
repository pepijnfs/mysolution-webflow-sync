<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow">
    <title>Mysolution Sync Dashboard | Base Select</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;500;600;700&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <script>
        // Simple HTTP Basic Authentication
        (function() {
            // Only run on status.baseselect.nl
            if (window.location.hostname === 'status.baseselect.nl') {
                // Check if user is already authenticated
                const isAuthenticated = sessionStorage.getItem('dashboard_auth');
                
                if (!isAuthenticated) {
                    const username = prompt('Username:');
                    const password = prompt('Password:');
                    
                    // Simple credential check - you should update these with your own credentials
                    if (username === 'baseselect' && password === 'dashboard2024') {
                        sessionStorage.setItem('dashboard_auth', 'true');
                    } else {
                        alert('Authentication failed');
                        // Redirect to homepage or show access denied
                        window.location.href = 'https://baseselect.nl';
                    }
                }
            }
        })();
    </script>
    <style>
        :root {
            --primary-color: #2750e2;
            --primary-light: #4a6fe9;
            --primary-dark: #1c3cb0;
            --button-color: #ff7300;
            --button-hover: #e56700;
            --success-color: #28a745;
            --warning-color: #ffc107;
            --danger-color: #dc3545;
            --info-color: #17a2b8;
            --bg-primary: #fff;
            --bg-secondary: #f4f1ff;
            --text-primary: #333;
            --text-secondary: #555;
            --text-muted: #777;
            --border-color: #e0e0e0;
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.12);
            --shadow-md: 0 4px 6px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0,0,0,0.1);
            --border-radius: 8px;
            --transition: all 0.3s ease;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            line-height: 1.6;
            padding: 0;
            margin: 0;
        }

        h1, h2, h3, h4, h5, h6 {
            font-family: 'Roboto', sans-serif;
            color: var(--primary-color);
            margin-bottom: 1rem;
            font-weight: 600;
        }

        h1 {
            font-size: 1.8rem;
            margin-bottom: 0rem;
            color: #232535;
        }

        h2 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
            font-weight: 500;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 1rem;
        }

        header {
            background-color: var(--bg-primary);
            box-shadow: var(--shadow-sm);
            padding: 1.25rem 0;
            margin-bottom: 2rem;
        }

        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .logo img {
            height: 40px;
        }

        .actions {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1.5rem 0;
        }

        button, .btn {
            background-color: var(--button-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            padding: 0.75rem 1.25rem;
            font-family: 'Nunito', sans-serif;
            font-weight: 600;
            font-size: 0.95rem;
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            text-decoration: none;
        }

        button:hover, .btn:hover {
            background-color: var(--button-hover);
        }

        button:disabled, .btn:disabled {
            background-color: var(--text-muted);
            cursor: not-allowed;
        }

        .btn-primary {
            background-color: var(--primary-color);
        }

        .btn-primary:hover {
            background-color: var(--primary-dark);
        }

        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .card {
            background-color: var(--bg-primary);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-sm);
            padding: 1.5rem;
            height: 100%;
        }

        .status-box {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .status-row {
            display: flex;
            justify-content: space-between;
            padding: 0.75rem 0;
            border-bottom: 1px solid var(--border-color);
        }

        .status-row:last-child {
            border-bottom: none;
        }

        .status-label {
            font-weight: 600;
            color: var(--text-secondary);
        }

        .status-value {
            font-weight: 500;
            color: var(--primary-color);
            text-align: right;
            font-size: 0.9rem;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .toggle-label {
            font-weight: 500;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: var(--transition);
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: var(--transition);
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--primary-color);
        }

        input:focus + .slider {
            box-shadow: 0 0 1px var(--primary-color);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .log-section {
            margin-top: 2rem;
        }

        .log-container {
            background-color: #272830;
            color: #f8f8f2;
            border-radius: var(--border-radius);
            padding: 1rem;
            height: 300px;
            overflow-y: auto;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.85rem;
            line-height: 1.5;
        }

        .log-entry {
            margin-bottom: 0.5rem;
            padding: 0.25rem 0;
            border-bottom: 1px solid #3a3a44;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .success {
            color: #50fa7b;
        }

        .error {
            color: #ff5555;
        }

        .warning {
            color: #f1fa8c;
        }

        .info {
            color: #8be9fd;
        }

        .loader {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .api-section {
            margin-top: 2rem;
            margin-bottom: 3rem;
        }

        .endpoint {
            background-color: var(--bg-primary);
            border-radius: var(--border-radius);
            padding: 1rem;
            margin-bottom: 1rem;
            box-shadow: var(--shadow-sm);
            border-left: 3px solid var(--primary-color);
        }

        .endpoint-header {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .method {
            background-color: var(--primary-color);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.85rem;
            margin-right: 0.75rem;
        }

        .url {
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
            color: var(--text-primary);
        }

        .description {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 240px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.85rem;
            font-weight: normal;
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        footer {
            background-color: var(--bg-primary);
            padding: 1.5rem 0;
            text-align: center;
            margin-top: 2rem;
            border-top: 1px solid var(--border-color);
        }

        .footer-content {
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        .badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 50px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: 0.5rem;
        }

        .badge-success {
            background-color: var(--success-color);
            color: white;
        }

        .badge-primary {
            background-color: var(--primary-color);
            color: white;
        }

        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            .actions {
                flex-wrap: wrap;
            }
            
            button, .btn {
                width: 100%;
            }
            
            .toggle-container {
                width: 100%;
                justify-content: space-between;
            }
        }

        .dashboard-log-container {
            margin-top: 2rem;
            margin-bottom: 2rem;
        }

        @media (min-width: 992px) {
            .dashboard {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
                gap: 1.5rem;
                margin-bottom: 2rem;
            }
            
            .dashboard-log-layout {
                display: grid;
                grid-template-columns: 1fr 2fr;
                gap: 1.5rem;
                margin-bottom: 2rem;
            }

            .dashboard-log-container {
                margin-top: 0;
                height: 100%;
            }

            .dashboard-log-container .card {
                height: 100%;
            }

            .dashboard-log-container .log-container {
                height: 400px;
            }
        }

        @media (max-width: 991px) {
            .dashboard-log-layout {
                display: flex;
                flex-direction: column;
                gap: 1.5rem;
            }
            
            .dashboard-log-container {
                margin-top: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <div class="header-content">
                <div class="logo">
                    <img src="./images/base-select-logo.png" alt="Base Select Logo">
                    <h1>Mysolution Sync Dashboard</h1>
                </div>
            </div>
        </div>
    </header>

    <main class="container">
        <p class="intro">Deze service synchroniseert vacature- en kandidaatgegevens tussen Mysolution ATS en Webflow CMS.</p>
        
        <div class="actions">
            <div class="tooltip">
                <button id="sync-now-btn">Mini-Sync</button>
                <span class="tooltiptext">Synchroniseert alleen vacatures die zijn gewijzigd sinds de laatste mini-sync. Sneller en efficiënter voor regelmatige updates.</span>
            </div>
            <div class="tooltip">
                <button id="full-sync-btn" class="btn-primary">Volledige Sync</button>
                <span class="tooltiptext">Synchroniseert alle vacatures ongeacht de wijzigingsdatum. Gebruik dit om volledige synchronisatie te garanderen bij problemen.</span>
            </div>
            <div class="toggle-container">
                <span class="toggle-label">Auto-Publiceren:</span>
                <label class="switch">
                    <input type="checkbox" id="auto-publish-toggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="tooltip">
                <button id="publish-now-btn" class="btn-primary">Publiceer naar Webflow</button>
                <span class="tooltiptext">Publiceer handmatig alle wijzigingen naar Webflow (staging + productie baseselect.nl).</span>
            </div>
        </div>
        
        <div class="dashboard">
            <div class="card">
                <h2>Service Status</h2>
                <div class="status-box">
                    <div class="status-row">
                        <span class="status-label">Status:</span>
                        <span class="status-value" id="service-status">Actief</span>
                    </div>
                    <div class="status-row">
                        <span class="status-label">Omgeving:</span>
                        <span class="status-value" id="environment">Ontwikkeling</span>
                    </div>
                    <div class="status-row">
                        <span class="status-label">Uptime:</span>
                        <span class="status-value" id="uptime">Laden...</span>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h2>Sync Status</h2>
                <div class="status-box">
                    <div class="status-row">
                        <span class="status-label">Laatste Volledige Sync:</span>
                        <span class="status-value" id="last-full-sync">Laden...</span>
                    </div>
                    <div class="status-row">
                        <span class="status-label">Laatste Mini-Sync:</span>
                        <span class="status-value" id="last-incremental-sync">Laden...</span>
                    </div>
                    <div class="status-row">
                        <span class="status-label">Volgende Mini-Sync:</span>
                        <span class="status-value" id="next-sync">Laden...</span>
                    </div>
                    <div class="status-row">
                        <span class="status-label">Auto-Publiceren:</span>
                        <span class="status-value" id="publishing-status">Laden...</span>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h2>Vacature Statistieken</h2>
                <div class="status-box">
                    <div class="status-row">
                        <span class="status-label">Vacatures in Mysolution:</span>
                        <span class="status-value" id="mysolution-job-count">-</span>
                    </div>
                    <div class="status-row">
                        <span class="status-label">Vacatures in Webflow:</span>
                        <span class="status-value" id="webflow-job-count">-</span>
                    </div>
                    <div class="status-row">
                        <span class="status-label">Laatste Publicatie:</span>
                        <span class="status-value" id="last-publish">-</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="dashboard-log-layout">
            <div>
                <div class="card">
                    <h2>Laatste Sync Resultaten</h2>
                    <div class="status-box">
                        <div class="status-row">
                            <span class="status-label">Totaal Vacatures:</span>
                            <span class="status-value" id="sync-total-jobs">-</span>
                        </div>
                        <div class="status-row">
                            <span class="status-label">Succesvol Bijgewerkt:</span>
                            <span class="status-value" id="sync-successful">-</span>
                        </div>
                        <div class="status-row">
                            <span class="status-label">Overgeslagen:</span>
                            <span class="status-value" id="sync-skipped">-</span>
                        </div>
                        <div class="status-row">
                            <span class="status-label">Mislukt:</span>
                            <span class="status-value" id="sync-failed">-</span>
                        </div>
                        <div class="status-row">
                            <span class="status-label">Laatste Sync Type:</span>
                            <span class="status-value" id="sync-type">-</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="dashboard-log-container">
                <div class="card">
                    <h2>Sync Logboek</h2>
                    <div id="log-container" class="log-container">
                        <div class="log-entry">Initialiseren van vacature sync dashboard...</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="api-section">
            <div class="card">
                <h2>API Endpoints</h2>
                <div class="endpoint">
                    <div class="endpoint-header">
                        <span class="method">GET</span>
                        <span class="url">/health</span>
                    </div>
                    <div class="description">Gezondheidscontrole eindpunt</div>
                </div>
                <div class="endpoint">
                    <div class="endpoint-header">
                        <span class="method">POST</span>
                        <span class="url">/api/jobs/sync</span>
                    </div>
                    <div class="description">Start een handmatige vacature synchronisatie</div>
                </div>
                <div class="endpoint">
                    <div class="endpoint-header">
                        <span class="method">POST</span>
                        <span class="url">/api/admin/reset-sync</span>
                    </div>
                    <div class="description">Reset sync status en start een volledige sync (vereist admin API sleutel)</div>
                </div>
                <div class="endpoint">
                    <div class="endpoint-header">
                        <span class="method">GET</span>
                        <span class="url">/api/admin/publishing/status</span>
                    </div>
                    <div class="description">Bekijk publicatie status (vereist admin API sleutel)</div>
                </div>
                <div class="endpoint">
                    <div class="endpoint-header">
                        <span class="method">POST</span>
                        <span class="url">/api/admin/publishing/publish</span>
                    </div>
                    <div class="description">Forceer publicatie van alle wijzigingen (vereist admin API sleutel)</div>
                </div>
            </div>
        </div>
    </main>

    <footer>
        <div class="container">
            <div class="footer-content">
                <p>© 2025 Base Select | Mysolution Vacature Synchronisatie Service</p>
            </div>
        </div>
    </footer>

    <script>
        // Configuration
        const adminApiKey = '4azk?mkxEFBAX&x&TSeJH!q@y?9TJ@YE!ipgp9ze'; // Updated to match value from .env
        let syncInProgress = false;
        let publishInProgress = false;
        let eventSource = null; // For SSE connection
        
        // Elements
        const syncNowBtn = document.getElementById('sync-now-btn');
        const fullSyncBtn = document.getElementById('full-sync-btn');
        const publishNowBtn = document.getElementById('publish-now-btn');
        const autoPublishToggle = document.getElementById('auto-publish-toggle');
        const logContainer = document.getElementById('log-container');
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Start updating UI components
            fetchDeploymentTime(); // Fetch deployment time for uptime calculation
            updateUptime();
            updateServiceHealth();
            updatePublishingStatus();
            loadJobCounts();
            fetchSyncInterval(); // Fetch sync interval for next sync calculation
            
            // Connect to real-time event stream
            connectToEventStream();
            
            // Set up periodic refreshes (as backup if SSE fails)
            setInterval(updateUptime, 1000);
            setInterval(updateServiceHealth, 30000);
            setInterval(updatePublishingStatus, 30000);
            setInterval(loadJobCounts, 60000);
            
            // Set up event listeners
            autoPublishToggle.addEventListener('change', toggleAutoPublish);
            syncNowBtn.addEventListener('click', triggerJobSync);
            fullSyncBtn.addEventListener('click', triggerFullSync);
            publishNowBtn.addEventListener('click', triggerPublish);
            
            // Log initialization
            addLogEntry('Dashboard succesvol geïnitialiseerd');
        });
        
        // Connect to real-time event stream
        function connectToEventStream() {
            if (!!window.EventSource) {
                // Close any existing connection
                if (eventSource) {
                    eventSource.close();
                }
                
                // Try the correct event stream endpoint with a fallback mechanism
                const eventEndpoints = [
                    '/api/events',                      // Standard endpoint
                    '/api/stream',                      // Alternative endpoint
                    '/api/admin/events',                // Admin endpoint
                    '/api/admin/sync/events',           // Sync-specific event stream
                    '/api/admin/stream',                // Alternative admin endpoint
                    '/api/admin/logs/stream'            // Logs-specific stream
                ];
                
                let currentEndpointIndex = 0;
                
                // Keep track of processed log IDs to avoid duplicates
                const processedLogIds = new Set();
                
                function tryConnectEventSource() {
                    if (currentEndpointIndex >= eventEndpoints.length) {
                        // We've tried all endpoints, set up polling as fallback
                        addLogEntry('Kon geen event stream verbinding maken. Fallback naar polling', 'warning');
                        setupPollingFallback();
                        return;
                    }
                    
                    const endpoint = eventEndpoints[currentEndpointIndex];
                    addLogEntry(`Probeer event stream eindpunt: ${endpoint}`, 'info');
                    
                    // Include API key for admin endpoints
                    let endpointWithAuth = endpoint;
                    
                    // Add proper query parameter
                    if (endpointWithAuth.includes('?')) {
                        endpointWithAuth += '&';
                    } else {
                        endpointWithAuth += '?';
                    }
                    
                    // Only add a single API key parameter to avoid confusion
                    if (endpoint.includes('/admin/')) {
                        endpointWithAuth += 'api_key=' + encodeURIComponent(adminApiKey);
                    }
                    
                    // Set a reconnection timer to detect server reboots
                    let reconnectTimer = null;
                    
                    // Event source error handler
                    const handleError = function(e) {
                        console.error('SSE verbinding fout:', e);
                        
                        // Clear any existing reconnection timer
                        if (reconnectTimer) {
                            clearTimeout(reconnectTimer);
                        }
                        
                        // Set a new timer to attempt reconnection after delay
                        reconnectTimer = setTimeout(function() {
                            addLogEntry('Probeer om verbinding te herstellen met event stream...', 'info');
                            eventSource.close();
                            currentEndpointIndex = (currentEndpointIndex + 1) % eventEndpoints.length; // Cycle through endpoints
                            tryConnectEventSource();
                        }, 2000); // 2 second delay
                    };
                    
                    try {
                        // Create a new EventSource connection
                        eventSource = new EventSource(endpointWithAuth);
                        
                        // Connection opened handler
                        eventSource.addEventListener('open', function() {
                            // Clear reconnection timer if successful
                            if (reconnectTimer) {
                                clearTimeout(reconnectTimer);
                                reconnectTimer = null;
                            }
                            
                            console.log(`SSE verbinding succesvol gemaakt met ${endpoint}`);
                            addLogEntry(`Real-time verbinding succesvol gemaakt met ${endpoint}`, 'success');
                            localStorage.setItem('workingEventStreamEndpoint', endpoint);
                        });
                        
                        // Handle log events
                        eventSource.addEventListener('log', function(e) {
                            try {
                                const logData = JSON.parse(e.data);
                                addLogEntry(logData.message, logData.level || 'info');
                            } catch (error) {
                                console.error('Error parsing log event:', error);
                                addLogEntry(e.data, 'info');
                            }
                        });
                        
                        // Handle sync events
                        eventSource.addEventListener('sync', function(e) {
                            try {
                                const syncData = JSON.parse(e.data);
                                
                                // Update sync summary if available
                                if (syncData.syncResults) {
                                    document.getElementById('sync-total-jobs').textContent = 
                                        syncData.syncResults.total || '-';
                                    document.getElementById('sync-successful').textContent = 
                                        syncData.syncResults.successful || '-';
                                    document.getElementById('sync-skipped').textContent = 
                                        syncData.syncResults.skipped || '-';
                                    document.getElementById('sync-failed').textContent = 
                                        syncData.syncResults.failed || '-';
                                    document.getElementById('sync-type').textContent = 
                                        syncData.syncResults.type || '-';
                                }
                                
                                // Update last sync time and next scheduled sync
                                if (syncData.lastSync) {
                                    // Update based on sync type
                                    if (syncData.syncType === 'full') {
                                        document.getElementById('last-full-sync').textContent = 
                                            new Date(syncData.lastSync).toLocaleString();
                                    } else if (syncData.syncType === 'incremental') {
                                        document.getElementById('last-incremental-sync').textContent = 
                                            new Date(syncData.lastSync).toLocaleString();
                                    }
                                    
                                    // Always update next sync time
                                    updateNextSyncTime();
                                }
                                
                                // Update job counts if available
                                if (syncData.jobCounts) {
                                    if (syncData.jobCounts.mysolution !== undefined) {
                                        document.getElementById('mysolution-job-count').textContent = 
                                            syncData.jobCounts.mysolution;
                                    }
                                    if (syncData.jobCounts.webflow !== undefined) {
                                        document.getElementById('webflow-job-count').textContent = 
                                            syncData.jobCounts.webflow;
                                    }
                                }
                                
                                // Update publishing status if available
                                if (syncData.publishTime) {
                                    document.getElementById('last-publish').textContent = 
                                        new Date(syncData.publishTime).toLocaleString();
                                }
                            } catch (error) {
                                console.error('Error parsing sync event:', error);
                            }
                        });
                        
                        // Handle errors
                        eventSource.addEventListener('error', handleError);
                        
                    } catch (error) {
                        console.error('Error creating EventSource:', error);
                        handleError(error);
                    }
                }
                
                // If we previously found a working endpoint, try it first
                const savedEndpoint = localStorage.getItem('workingEventStreamEndpoint');
                if (savedEndpoint) {
                    const savedIndex = eventEndpoints.indexOf(savedEndpoint);
                    if (savedIndex >= 0) {
                        // Move the saved endpoint to the front
                        currentEndpointIndex = 0;
                        eventEndpoints.splice(savedIndex, 1);
                        eventEndpoints.unshift(savedEndpoint);
                    }
                }
                
                // Start trying endpoints
                tryConnectEventSource();
                
                // Add a listener for visibility changes to handle browser tab switching
                document.addEventListener('visibilitychange', function() {
                    if (document.visibilityState === 'visible') {
                        // When the tab becomes visible, check if the connection is still alive
                        if (eventSource && eventSource.readyState === EventSource.CLOSED) {
                            addLogEntry('Connection lost while tab was inactive, reconnecting...', 'info');
                            eventSource.close();
                            currentEndpointIndex = 0; // Start from the beginning
                            tryConnectEventSource();
                        }
                    }
                });
                
                // Polling fallback for when SSE is not available
                function setupPollingFallback() {
                    addLogEntry('Setting up polling fallback for real-time updates', 'info');
                    
                    // Poll for logs every 30 seconds instead of 5 seconds
                    setInterval(fetchRecentLogs, 30000);
                    
                    // Poll for sync status every 60 seconds instead of 10 seconds
                    setInterval(fetchSyncStatus, 60000);
                }
            } else {
                console.warn('SSE not supported by browser');
                addLogEntry('Real-time updates not supported by your browser', 'warning');
            }
        }
        
        // Simple uptime counter based on deployment time
        let deploymentTime = null;
        let deploymentUnixTimestamp = null;
        let syncIntervalMinutes = 5; // Updated to 5 minutes
        
        // Fetch deployment time from server
        async function fetchDeploymentTime() {
            try {
                console.log('Fetching deployment time from server...');
                const response = await fetch('/api/admin/deployment/info', {
                    headers: {
                        'x-api-key': adminApiKey
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('Deployment info received:', data.data);
                    
                    if (data.data && data.data.deploymentTime) {
                        deploymentTime = new Date(data.data.deploymentTime);
                        deploymentUnixTimestamp = data.data.unixTimestamp;
                        
                        console.log('Deployment time set to:', deploymentTime);
                        console.log('Source:', data.data.source);
                        
                        if (data.data.commitHash) {
                            console.log('Commit hash:', data.data.commitHash);
                        }
                        
                        updateUptime(); // Initial update
                    } else {
                        throw new Error('Invalid deployment data structure');
                    }
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                console.error('Error fetching deployment time:', error);
                addLogEntry(`Could not fetch deployment time: ${error.message}. Using fallback.`, 'warning');
                
                // Fallback: Use a reasonable default (5 minutes ago)
                deploymentTime = new Date(Date.now() - 5 * 60 * 1000);
                deploymentUnixTimestamp = Math.floor(deploymentTime.getTime() / 1000);
                console.log('Using fallback deployment time:', deploymentTime);
                
                updateUptime(); // Initial update with fallback
            }
        }
        
        // Update uptime display based on deployment time
        function updateUptime() {
            if (!deploymentTime) {
                document.getElementById('uptime').textContent = '--:--:--';
                return;
            }
            
            try {
                const now = new Date();
                const uptimeMs = now - deploymentTime;
                
                // Ensure we don't show negative uptime
                if (uptimeMs < 0) {
                    document.getElementById('uptime').textContent = '00:00:00';
                    return;
                }
                
                const hours = Math.floor(uptimeMs / (1000 * 60 * 60));
                const minutes = Math.floor((uptimeMs % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((uptimeMs % (1000 * 60)) / 1000);
                
                const formattedUptime = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                document.getElementById('uptime').textContent = formattedUptime;
                
                // Debug logging every 30 seconds
                if (seconds === 0 || seconds === 30) {
                    console.log(`Uptime update: ${formattedUptime} (${Math.floor(uptimeMs / 1000)}s since ${deploymentTime.toISOString()})`);
                }
            } catch (error) {
                console.error('Error updating uptime:', error);
                document.getElementById('uptime').textContent = 'Error';
            }
        }
        
        // Fetch sync interval from server for next sync calculation
        async function fetchSyncInterval() {
            try {
                const response = await fetch('/api/admin/sync/schedule/status', {
                    headers: {
                        'x-api-key': adminApiKey
                    }
                }).catch(() => ({ ok: false }));
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.data && data.data.interval) {
                        syncIntervalMinutes = data.data.interval;
                        console.log(`Sync interval set to ${syncIntervalMinutes} minutes from server configuration`);
                    }
                }
            } catch (error) {
                console.error('Error fetching sync interval:', error);
            }
        }
        
        // Update publishing status and toggle
        async function updatePublishingStatus() {
            try {
                const response = await fetch('/api/admin/publishing/status', {
                    headers: {
                        'x-api-key': adminApiKey
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Update status display
                    document.getElementById('publishing-status').textContent = 
                        data.data.autoPublishEnabled ? 'Ingeschakeld' : 'Uitgeschakeld';
                    
                    // Update toggle without triggering change event
                    autoPublishToggle.checked = data.data.autoPublishEnabled;
                    
                    // Update last publish time
                    if (data.data.lastPublishTime) {
                        document.getElementById('last-publish').textContent = 
                            new Date(data.data.lastPublishTime).toLocaleString();
                    }
                    
                    // Update last sync time if available
                    updateLastSyncTime();
                }
            } catch (error) {
                console.error('Error fetching publishing status:', error);
                addLogEntry(`Error fetching publishing status: ${error.message}`, 'error');
            }
        }
        
        // Update service health status
        async function updateServiceHealth() {
            try {
                const response = await fetch('/health');
                
                if (response.ok) {
                    const data = await response.json();
                    document.getElementById('service-status').textContent = data.status;
                    document.getElementById('environment').textContent = data.environment;
                    
                    // Predict next sync time if possible
                    updateNextSyncTime();
                }
            } catch (error) {
                document.getElementById('service-status').textContent = 'Unavailable';
                console.error('Error fetching health status:', error);
                addLogEntry(`Health check failed: ${error.message}`, 'error');
            }
        }
        
        // Get the sync state to update last sync time
        async function updateLastSyncTime() {
            try {
                // Add cache=dashboard parameter to use server caching
                const response = await fetch('/api/admin/sync/status?cache=dashboard', {
                    headers: {
                        'x-api-key': adminApiKey
                    }
                }).catch(() => ({ ok: false })); // Handle 404 gracefully
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.data) {
                        // Update full sync time
                        if (data.data.lastFullSync) {
                            document.getElementById('last-full-sync').textContent = 
                                new Date(data.data.lastFullSync).toLocaleString();
                            localStorage.setItem('lastFullSyncTime', new Date(data.data.lastFullSync).getTime());
                        } else {
                            // Check localStorage for fallback
                            const cachedFullSync = localStorage.getItem('lastFullSyncTime');
                            if (cachedFullSync) {
                                document.getElementById('last-full-sync').textContent = 
                                    new Date(parseInt(cachedFullSync)).toLocaleString();
                            } else {
                                document.getElementById('last-full-sync').textContent = 'Nog niet uitgevoerd';
                            }
                        }
                        
                        // Update incremental sync time
                        if (data.data.lastIncrementalSync) {
                            document.getElementById('last-incremental-sync').textContent = 
                                new Date(data.data.lastIncrementalSync).toLocaleString();
                            localStorage.setItem('lastIncrementalSyncTime', new Date(data.data.lastIncrementalSync).getTime());
                        } else {
                            // Check localStorage for fallback
                            const cachedIncrementalSync = localStorage.getItem('lastIncrementalSyncTime');
                            if (cachedIncrementalSync) {
                                document.getElementById('last-incremental-sync').textContent = 
                                    new Date(parseInt(cachedIncrementalSync)).toLocaleString();
                            } else {
                                document.getElementById('last-incremental-sync').textContent = 'Nog niet uitgevoerd';
                            }
                        }
                        
                        // Update last sync metrics if available
                        if (data.data.lastSyncResults) {
                            document.getElementById('sync-total-jobs').textContent = 
                                data.data.lastSyncResults.total || '-';
                            document.getElementById('sync-successful').textContent = 
                                data.data.lastSyncResults.successful || '-';
                            document.getElementById('sync-skipped').textContent = 
                                data.data.lastSyncResults.skipped || '-';
                            document.getElementById('sync-failed').textContent = 
                                data.data.lastSyncResults.failed || '-';
                            document.getElementById('sync-type').textContent = 
                                data.data.lastSyncResults.type || '-';
                        }
                    }
                } else {
                    // Fallback to checking local storage
                    const lastFullSyncTime = localStorage.getItem('lastFullSyncTime');
                    const lastIncrementalSyncTime = localStorage.getItem('lastIncrementalSyncTime');
                    
                    if (lastFullSyncTime) {
                        document.getElementById('last-full-sync').textContent = 
                            new Date(parseInt(lastFullSyncTime)).toLocaleString();
                    } else {
                        document.getElementById('last-full-sync').textContent = 'Unknown';
                    }
                    
                    if (lastIncrementalSyncTime) {
                        document.getElementById('last-incremental-sync').textContent = 
                            new Date(parseInt(lastIncrementalSyncTime)).toLocaleString();
                    } else {
                        document.getElementById('last-incremental-sync').textContent = 'Unknown';
                    }
                }
            } catch (error) {
                console.error('Error fetching last sync time:', error);
                document.getElementById('last-full-sync').textContent = 'Error';
                document.getElementById('last-incremental-sync').textContent = 'Error';
            }
        }
        
        // Calculate and display next scheduled sync time
        function updateNextSyncTime() {
            try {
                const lastSyncText = document.getElementById('last-incremental-sync').textContent;
                if (lastSyncText && lastSyncText !== 'Loading...' && lastSyncText !== 'Unknown' && lastSyncText !== 'Error') {
                    const lastSync = new Date(lastSyncText);
                    
                    // If lastSync is valid, calculate next sync
                    if (!isNaN(lastSync.getTime())) {
                        // Calculate next sync time based on the cron pattern (every X minutes)
                        const nextSync = new Date(Math.ceil(lastSync.getTime() / (syncIntervalMinutes * 60 * 1000)) * (syncIntervalMinutes * 60 * 1000) + (syncIntervalMinutes * 60 * 1000));
                        document.getElementById('next-sync').textContent = nextSync.toLocaleString();
                        return;
                    }
                }
                
                // If we can't calculate from last sync, use current time
                const now = new Date();
                // Find the next interval based on current time
                const nextSync = new Date(Math.ceil(now.getTime() / (syncIntervalMinutes * 60 * 1000)) * (syncIntervalMinutes * 60 * 1000));
                document.getElementById('next-sync').textContent = nextSync.toLocaleString();
            } catch (e) {
                console.error('Error calculating next sync time:', e);
                // Provide a reasonable fallback instead of "Unknown"
                const now = new Date();
                const nextSync = new Date(now.getTime() + (syncIntervalMinutes * 60 * 1000));
                document.getElementById('next-sync').textContent = nextSync.toLocaleString();
            }
        }
        
        // Load job counts from Mysolution and Webflow
        async function loadJobCounts() {
            try {
                // Add cache=dashboard parameter to use server caching
                const response = await fetch('/api/admin/jobs/count?cache=dashboard', {
                    headers: {
                        'x-api-key': adminApiKey
                    }
                }).catch(() => ({ ok: false })); // Handle 404 gracefully
                
                if (response.ok) {
                    const data = await response.json();
                    
                    if (data.data) {
                        if (data.data.mysolution !== undefined) {
                            document.getElementById('mysolution-job-count').textContent = data.data.mysolution;
                        }
                        
                        if (data.data.webflow !== undefined) {
                            document.getElementById('webflow-job-count').textContent = data.data.webflow;
                        }
                    }
                }
            } catch (error) {
                console.error('Error fetching job counts:', error);
            }
        }
        
        // Toggle auto-publish setting
        async function toggleAutoPublish() {
            const enabled = autoPublishToggle.checked;
            
            try {
                addLogEntry(`${enabled ? 'Enabling' : 'Disabling'} auto-publish...`);
                
                const endpoint = enabled ? '/api/admin/publishing/enable' : '/api/admin/publishing/disable';
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': adminApiKey
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    addLogEntry(`Auto-publish ${enabled ? 'enabled' : 'disabled'} successfully`, 'success');
                    
                    // Update status display
                    document.getElementById('publishing-status').textContent = 
                        data.data.autoPublishEnabled ? 'Ingeschakeld' : 'Uitgeschakeld';
                } else {
                    // Revert toggle if request failed
                    autoPublishToggle.checked = !enabled;
                    const errorData = await response.json();
                    addLogEntry(`Failed to ${enabled ? 'enable' : 'disable'} auto-publish: ${errorData.message || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                console.error(`Error ${enabled ? 'enabling' : 'disabling'} auto-publish:`, error);
                autoPublishToggle.checked = !enabled; // Revert toggle
                addLogEntry(`Error ${enabled ? 'enabling' : 'disabling'} auto-publish: ${error.message}`, 'error');
            }
        }
        
        // Trigger job sync
        async function triggerJobSync() {
            if (syncInProgress) return;
            
            syncInProgress = true;
            syncNowBtn.disabled = true;
            syncNowBtn.innerHTML = 'Syncing... <span class="loader"></span>';
            
            try {
                addLogEntry('Starting incremental job sync...');
                
                const response = await fetch('/api/admin/sync/run-incremental', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': adminApiKey
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Store last sync time for UI
                    const nowTimestamp = Date.now();
                    localStorage.setItem('lastIncrementalSyncTime', nowTimestamp);
                    
                    // Update last sync display immediately
                    document.getElementById('last-incremental-sync').textContent = new Date(nowTimestamp).toLocaleString();
                    
                    // Update sync summary with results
                    if (data.data) {
                        document.getElementById('sync-successful').textContent = data.data.successful || '0';
                        document.getElementById('sync-skipped').textContent = data.data.skipped || '0';
                        document.getElementById('sync-failed').textContent = data.data.failed || '0';
                        document.getElementById('sync-total-jobs').textContent = 
                            (parseInt(data.data.successful || 0) + parseInt(data.data.skipped || 0) + parseInt(data.data.failed || 0)).toString();
                        document.getElementById('sync-type').textContent = 'Incremental';
                    }
                    
                    // Immediately calculate next sync time based on current time
                    updateNextSyncTime();
                    
                    addLogEntry('Incremental job sync completed successfully', 'success');
                    addLogEntry(`Results: ${data.data.successful} jobs updated, ${data.data.skipped} skipped, ${data.data.failed} failed`);
                    
                    // Refresh all other UI data 
                    loadJobCounts();
                } else {
                    const errorData = await response.json();
                    addLogEntry(`Sync failed: ${errorData.message || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                console.error('Error triggering job sync:', error);
                addLogEntry(`Error triggering job sync: ${error.message}`, 'error');
            } finally {
                syncInProgress = false;
                syncNowBtn.disabled = false;
                syncNowBtn.textContent = 'Incremental Sync';
            }
        }
        
        // Full sync function
        async function triggerFullSync() {
            if (syncInProgress) return;
            
            syncInProgress = true;
            fullSyncBtn.disabled = true;
            fullSyncBtn.innerHTML = 'Syncing... <span class="loader"></span>';
            
            try {
                addLogEntry('Starting full job sync... (Dit zal ALLE vacatures synchroniseren en kan langer duren)', 'warning');
                
                const response = await fetch('/api/jobs/sync', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Store last sync time for UI
                    const nowTimestamp = Date.now();
                    localStorage.setItem('lastFullSyncTime', nowTimestamp);
                    
                    // Update last sync display immediately
                    document.getElementById('last-full-sync').textContent = new Date(nowTimestamp).toLocaleString();
                    
                    // Update sync summary with results
                    if (data.data) {
                        document.getElementById('sync-successful').textContent = data.data.successful || '0';
                        document.getElementById('sync-skipped').textContent = data.data.skipped || '0';
                        document.getElementById('sync-failed').textContent = data.data.failed || '0';
                        document.getElementById('sync-total-jobs').textContent = 
                            (parseInt(data.data.successful || 0) + parseInt(data.data.skipped || 0) + parseInt(data.data.failed || 0)).toString();
                        document.getElementById('sync-type').textContent = 'Full';
                    }
                    
                    // Immediately calculate next sync time based on current time
                    updateNextSyncTime();
                    
                    addLogEntry('Full job sync completed successfully', 'success');
                    addLogEntry(`Results: ${data.data.successful} jobs updated, ${data.data.skipped} skipped, ${data.data.failed} failed`);
                    
                    // Refresh all other UI data
                    loadJobCounts();
                } else {
                    const errorData = await response.json();
                    addLogEntry(`Sync failed: ${errorData.message || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                console.error('Error triggering full sync:', error);
                addLogEntry(`Error triggering full sync: ${error.message}`, 'error');
            } finally {
                syncInProgress = false;
                fullSyncBtn.disabled = false;
                fullSyncBtn.textContent = 'Full Sync';
            }
        }
        
        // Trigger publish
        async function triggerPublish() {
            if (publishInProgress) return;
            
            publishInProgress = true;
            publishNowBtn.disabled = true;
            publishNowBtn.innerHTML = 'Publishing... <span class="loader"></span>';
            
            try {
                addLogEntry('Publiceren naar Webflow...');
                
                const response = await fetch('/api/admin/publishing/publish', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': adminApiKey
                    },
                    body: JSON.stringify({ reason: 'Manual publish from dashboard' })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    addLogEntry('Succesvol gepubliceerd naar Webflow', 'success');
                    
                    // Update last publish time
                    if (data.data && data.data.publishTime) {
                        document.getElementById('last-publish').textContent = 
                            new Date(data.data.publishTime).toLocaleString();
                    }
                } else {
                    const errorData = await response.json();
                    addLogEntry(`Publish failed: ${errorData.message || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                console.error('Error triggering publish:', error);
                addLogEntry(`Error publishing to Webflow: ${error.message}`, 'error');
            } finally {
                publishInProgress = false;
                publishNowBtn.disabled = false;
                publishNowBtn.textContent = 'Publish to Webflow';
            }
        }
        
        // Add entry to log
        function addLogEntry(message, level = 'info') {
            // Skip duplicates within a time window (last 5 seconds)
            const existingEntries = Array.from(logContainer.children);
            const now = Date.now();
            
            // Check for duplicates in recent entries
            for (let i = existingEntries.length - 1; i >= Math.max(0, existingEntries.length - 5); i--) {
                const existingEntry = existingEntries[i];
                const entryText = existingEntry.textContent.substring(existingEntry.textContent.indexOf(']') + 2);
                
                // If the message is the same and was added in the last 5 seconds, skip it
                if (entryText === message && (now - existingEntry.dataset.timestamp < 5000)) {
                    return; // Skip duplicate message
                }
            }
            
            const entry = document.createElement('div');
            entry.className = `log-entry ${level}`;
            entry.dataset.timestamp = now;
            
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
            
            // Limit log entries to prevent excessive DOM size
            while (logContainer.children.length > 100) {
                logContainer.removeChild(logContainer.firstChild);
            }
        }

        async function fetchRecentLogs() {
            try {
                const response = await fetch('/api/admin/logs/recent?api_key=' + encodeURIComponent(adminApiKey), {
                    headers: {
                        'x-api-key': adminApiKey
                    }
                }).catch(() => ({ ok: false }));
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.data && Array.isArray(data.data.logs)) {
                        // Process each log entry
                        data.data.logs.forEach(log => {
                            if (log.id && !processedLogIds.has(log.id)) {
                                addLogEntry(log.message, log.level || 'info');
                                processedLogIds.add(log.id);
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('Error fetching recent logs:', error);
            }
        }

        async function fetchSyncStatus() {
            try {
                updateLastSyncTime();
                // Limit job count updates to once per minute
                const now = Date.now();
                if (!window.lastJobCountUpdate || now - window.lastJobCountUpdate > 60000) {
                    loadJobCounts();
                    window.lastJobCountUpdate = now;
                }
            } catch (error) {
                console.error('Error updating sync status:', error);
            }
        }
    </script>
</body>
</html> 